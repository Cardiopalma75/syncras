<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Syncras – Under/Over 2.5 (Spiegabile • 2 CSV • Backtest)</title>
  <style>
    :root{--violet:#6C5CE7;--bg:#f7f7fb;--card:#fff;--border:#e7e7f5;--text:#111827;--muted:#6b7280}
    body{font-family:system-ui,Arial;margin:18px;background:var(--bg);color:var(--text)}
    h2{margin:0 0 10px 0}
    .muted{color:var(--muted)}
    .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:14px;margin-top:14px}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    .grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:10px}
    @media(max-width:920px){.grid{grid-template-columns:1fr}}
    input,select,button{padding:9px;border-radius:12px;border:1px solid #cfcfe6}
    input[type="file"]{padding:10px}
    button{cursor:pointer;background:var(--violet);color:#fff;border:0;font-weight:900;padding:12px 14px;border-radius:14px}
    button:hover{filter:brightness(.96)}
    .btn2{background:#111827}
    hr{border:none;border-top:1px solid #e9e9f7}
    .pill{display:inline-flex;gap:6px;align-items:center;border:1px solid var(--border);background:#fafafe;border-radius:999px;padding:6px 10px;font-size:12px;color:#555}
    table{border-collapse:collapse;width:100%;margin-top:12px;background:#fff;border:1px solid var(--border);border-radius:14px;overflow:hidden}
    th,td{border-bottom:1px solid #eee;padding:8px;text-align:right;font-size:13px;vertical-align:top}
    th{background:#fafafe;color:#333;font-size:12px}
    th:first-child,td:first-child{text-align:left}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .ok{color:#0a7}
    .bad{color:#c22}
    .warn{color:#d97706}
    small{color:#555;line-height:1.35}
  </style>
</head>
<body>
  <h2>Syncras – Under/Over 2.5 (Spiegabile • 2 CSV • Backtest)</h2>
  <div class="muted">
    Obiettivo: <b>statistiche e percentuali</b> Under/Over 2.5 <b>spiegabili</b> (quota X, spread |1-2|, GA recente).
    <br>Non servono quote Over/Under. Backtest = “quante partite avrei preso pre-match” + hit-rate (senza ROI).
  </div>

  <div class="card">
    <div class="grid">
      <div>
        <label><b>CSV RISULTATI (giocato)</b></label><br>
        <input id="csvResultsFile" type="file" accept=".csv,text/csv" style="width:100%">
        <small class="muted">Colonne tipiche: <span class="mono">date, HomeTeam/home_team, AwayTeam/away_team, FTHG, FTAG</span></small>
      </div>

      <div>
        <label><b>CSV QUOTE (pre-match 1/X/2)</b></label><br>
        <input id="csvQuotesFile" type="file" accept=".csv,text/csv" style="width:100%">
        <small class="muted">
          Colonne attese: <span class="mono">date, home_team, away_team, b365_1, b365_x, b365_2</span>
        </small>
      </div>

      <div>
        <label><b>Output</b></label><br>
        <div class="row">
          <span class="pill">✅ %Over/%Under</span>
          <span class="pill">✅ per quota X</span>
          <span class="pill">✅ per spread |1-2|</span>
          <span class="pill">✅ per GA</span>
          <span class="pill">✅ selezione top 2</span>
          <span class="pill">✅ backtest prese</span>
        </div>
        <small class="muted" style="display:block;margin-top:10px">
          Studio informativo. Nessun invito a scommettere.
        </small>
      </div>
    </div>

    <hr style="margin:14px 0">

    <div class="row">
      <label>N recenti (GA)</label><input id="N" type="number" value="12" style="width:90px">
      <label>Modalità selezione</label>
      <select id="mode">
        <option value="over" selected>SEGNALA OVER</option>
        <option value="under">SEGNALA UNDER</option>
        <option value="auto">AUTO (sceglie Over o Under)</option>
      </select>

      <label>Soglia Prob. min</label><input id="pMin" type="number" value="60" style="width:95px">
      <label>Top</label><input id="topK" type="number" value="2" style="width:70px">
    </div>

    <div class="row" style="margin-top:10px">
      <label>Bonus Over se X alta</label>
      <select id="useXBonus">
        <option value="on" selected>ON</option>
        <option value="off">OFF</option>
      </select>
      <label>X ≥</label><input id="xHigh" type="number" value="4.00" step="0.05" style="width:90px">
      <label>Bonus (+p)</label><input id="xBoost" type="number" value="0.03" step="0.01" style="width:90px">

      <span class="pill">range/spread = <span class="mono">|quota1 - quota2|</span></span>
    </div>

    <hr style="margin:14px 0">

    <div class="row">
      <button id="runBtn" type="button">1) Statistiche + Selezione (top 2)</button>
      <button id="btBtn" type="button" class="btn2">2) BACKTEST (pre-match prese)</button>
      <span id="status" class="muted"></span>
    </div>

    <small style="display:block;margin-top:10px">
      Nota: il backtest funziona sulle partite che sono <b>presenti sia nel CSV quote sia nel CSV risultati</b> (matchate per data+home+away).
    </small>
  </div>

  <div id="output"></div>

<script>
function normTeam(s){ return String(s||"").trim().toLowerCase(); }
function normKey(s){ return String(s||"").trim().toLowerCase(); }
function toNum(x){ const s=String(x??"").trim().replace(",","."); const n=Number(s); return Number.isFinite(n) ? n : NaN; }
function fmtPct(x){ return Number.isFinite(x) ? (x*100).toFixed(1)+"%" : "—"; }
function fmtNum(x){ return Number.isFinite(x) ? x.toFixed(2) : "—"; }

function parseCSV(text){
  const rows=[]; let row=[], cur="", inQ=false;
  for(let i=0;i<text.length;i++){
    const ch=text[i], nx=text[i+1];
    if(ch === '"'){ if(inQ && nx === '"'){ cur+='"'; i++; } else inQ = !inQ; continue; }
    if(!inQ && (ch===',' || ch===';')){ row.push(cur); cur=""; continue; }
    if(!inQ && ch==='\n'){ row.push(cur); rows.push(row); row=[]; cur=""; continue; }
    if(!inQ && ch==='\r') continue;
    cur+=ch;
  }
  row.push(cur); rows.push(row);
  if(rows.length && rows[rows.length-1].every(c=>String(c).trim()==="")) rows.pop();
  const header=(rows[0]||[]).map(x=>String(x).trim());
  return rows.slice(1).map(r=>{
    const o={};
    for(let i=0;i<header.length;i++) o[header[i]] = String(r[i]??"").trim().replace(/"/g,"");
    return o;
  });
}
function pick(o, keys){
  const map={}; for(const k in o) map[normKey(k)] = o[k];
  for(const k of keys){ const v = map[normKey(k)]; if(v!==undefined) return v; }
  return undefined;
}
function parseDateTs(s){
  const t=String(s??"").trim(); if(!t) return NaN;
  if(/^\d{4}-\d{2}-\d{2}$/.test(t)) return Date.parse(t+"T00:00:00Z");
  let m=t.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
  if(m){
    const dd=+m[1], mm=+m[2], yyyy=+m[3];
    const iso=`${String(yyyy).padStart(4,'0')}-${String(mm).padStart(2,'0')}-${String(dd).padStart(2,'0')}`;
    return Date.parse(iso+"T00:00:00Z");
  }
  m=t.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2})$/);
  if(m){
    const dd=+m[1], mm=+m[2], yy=+m[3];
    const yyyy=(yy>=70)?(1900+yy):(2000+yy);
    const iso=`${yyyy}-${String(mm).padStart(2,'0')}-${String(dd).padStart(2,'0')}`;
    return Date.parse(iso+"T00:00:00Z");
  }
  const x=Date.parse(t); return Number.isFinite(x)?x:NaN;
}
function normResultRow(o){
  const dateStr=String(pick(o,["date","match_date","data","giorno","Date","DATA"])||"").trim();
  const home_team=normTeam(pick(o,["home_team","hometeam","home","HomeTeam","CASA"])||"");
  const away_team=normTeam(pick(o,["away_team","awayteam","away","AwayTeam","TRASFERTA"])||"");
  const FTHG=pick(o,["FTHG","fthg","hg","home_goals","HomeGoals"]) ?? "";
  const FTAG=pick(o,["FTAG","ftag","ag","away_goals","AwayGoals"]) ?? "";
  const dateTs=parseDateTs(dateStr);
  return {dateStr,dateTs,home_team,away_team,FTHG:String(FTHG).trim(),FTAG:String(FTAG).trim()};
}
function normQuoteRow(o){
  const dateStr=String(pick(o,["date","match_date","data","giorno","Date","DATA"])||"").trim();
  const home_team=normTeam(pick(o,["home_team","hometeam","home","HomeTeam","CASA"])||"");
  const away_team=normTeam(pick(o,["away_team","awayteam","away","AwayTeam","TRASFERTA"])||"");
  const b365_1=pick(o,["b365_1","b365_h","B365H","odd1","odds_1","1","home"]) ?? "";
  const b365_x=pick(o,["b365_x","B365D","oddx","odds_x","X","draw"]) ?? "";
  const b365_2=pick(o,["b365_2","b365_a","B365A","odd2","odds_2","2","away"]) ?? "";
  const dateTs=parseDateTs(dateStr);
  return {dateStr,dateTs,home_team,away_team,b365_1:String(b365_1).trim(),b365_x:String(b365_x).trim(),b365_2:String(b365_2).trim()};
}
function keyOf(dateTs,home,away){ return `${dateTs}|${home}|${away}`; }

async function readFileText(file){
  return new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(String(r.result||"")); r.onerror=rej; r.readAsText(file); });
}

/* Poisson */
const factMemo={0:1,1:1,2:2,3:6,4:24,5:120,6:720,7:5040,8:40320,9:362880,10:3628800};
function factorial(n){ if(factMemo[n]) return factMemo[n]; let r=1; for(let i=2;i<=n;i++) r*=i; return r; }
function poissonCDF(k, mu){
  if(!Number.isFinite(mu) || mu<=0) return NaN;
  let sum=0;
  for(let i=0;i<=k;i++) sum += Math.exp(-mu) * Math.pow(mu,i) / factorial(i);
  return sum;
}
function pOver25(mu){ const pLe2=poissonCDF(2,mu); if(!Number.isFinite(pLe2)) return NaN; return 1-pLe2; }

function lastNMatches(results, team, N, beforeTs){
  return results
    .filter(r=>Number.isFinite(r.dateTs) && r.dateTs < beforeTs && (r.home_team===team || r.away_team===team))
    .sort((a,b)=>b.dateTs - a.dateTs)
    .slice(0,N);
}
function teamGFGA(results, team, N, beforeTs){
  const ms=lastNMatches(results,team,N,beforeTs);
  let gf=0, ga=0, n=0;
  for(const m of ms){
    const hg=toNum(m.FTHG), ag=toNum(m.FTAG);
    if(!Number.isFinite(hg) || !Number.isFinite(ag)) continue;
    if(m.home_team===team){ gf+=hg; ga+=ag; } else { gf+=ag; ga+=hg; }
    n++;
  }
  if(n<3) return {gf:NaN,ga:NaN,n};
  return {gf:gf/n, ga:ga/n, n};
}
function estimateMu(results, home, away, N, dateTs){
  const h=teamGFGA(results,home,N,dateTs);
  const a=teamGFGA(results,away,N,dateTs);
  if(!Number.isFinite(h.gf) || !Number.isFinite(h.ga) || !Number.isFinite(a.gf) || !Number.isFinite(a.ga)) return {mu:NaN};
  const muHome=(h.gf + a.ga)/2;
  const muAway=(a.gf + h.ga)/2;
  let mu = muHome + muAway;
  mu = Math.max(1.4, Math.min(4.2, mu));
  return {mu};
}
function applyXBonus(pOver, oddX, xHigh, xBoost, use){
  if(!use) return pOver;
  if(!Number.isFinite(oddX)) return pOver;
  if(oddX < xHigh) return pOver;
  const b = Math.max(0, Math.min(0.08, xBoost));
  return Math.max(0.02, Math.min(0.98, pOver + b));
}

/* Binning + tabelle */
function binLabel(val, edges){
  if(!Number.isFinite(val)) return "NA";
  for(let i=0;i<edges.length;i++){
    if(val<=edges[i]){
      const lo=(i===0)?"-∞":edges[i-1].toFixed(2);
      const hi=edges[i].toFixed(2);
      return `${lo}–${hi}`;
    }
  }
  return `${edges[edges.length-1].toFixed(2)}+`;
}
function addAgg(map, key, isOver){
  if(!map[key]) map[key]={n:0, over:0};
  map[key].n++; if(isOver) map[key].over++;
}
function aggToRows(map){
  return Object.keys(map).sort((a,b)=>map[b].n-map[a].n).map(k=>{
    const n=map[k].n, over=map[k].over;
    return {k,n,over,p:n?(over/n):0};
  });
}
function makeTable(title, rows){
  const body = rows.map(r=>`
    <tr>
      <td>${r.k}</td>
      <td class="mono">${r.n}</td>
      <td class="mono">${r.over}</td>
      <td><b>${(r.p*100).toFixed(1)}%</b></td>
      <td class="mono">${(100 - r.p*100).toFixed(1)}%</td>
    </tr>
  `).join("") || `<tr><td colspan="5" class="muted">Nessun dato</td></tr>`;
  return `
    <div class="card">
      <b>${title}</b>
      <table>
        <thead>
          <tr><th>Bin</th><th>N</th><th>Over</th><th>%Over</th><th>%Under</th></tr>
        </thead>
        <tbody>${body}</tbody>
      </table>
      <small class="muted">Over = gol totali ≥ 3. Under = gol totali ≤ 2.</small>
    </div>
  `;
}

/* 1) STATISTICHE + SELEZIONE */
async function run(){
  const status=document.getElementById("status");
  const output=document.getElementById("output");
  status.textContent="Carico CSV…"; output.innerHTML="";
  try{
    const fRes=document.getElementById("csvResultsFile").files?.[0];
    const fQuo=document.getElementById("csvQuotesFile").files?.[0];
    if(!fRes || !fQuo){ status.textContent="⚠️ Seleziona entrambi i CSV."; return; }

    const N=+document.getElementById("N").value||12;
    const mode=document.getElementById("mode").value;
    const pMin=(+document.getElementById("pMin").value||60)/100;
    const topK=Math.max(1,+document.getElementById("topK").value||2);

    const useXBonus=(document.getElementById("useXBonus").value==="on");
    const xHigh=+document.getElementById("xHigh").value||4.0;
    const xBoost=+document.getElementById("xBoost").value||0.03;

    const resText=await readFileText(fRes);
    const quoText=await readFileText(fQuo);

    const results=parseCSV(resText).map(normResultRow).filter(r=>r.dateStr && r.home_team && r.away_team && Number.isFinite(r.dateTs));
    const quotes=parseCSV(quoText).map(normQuoteRow).filter(q=>q.dateStr && q.home_team && q.away_team && Number.isFinite(q.dateTs));

    const resMap=new Map();
    for(const r of results) resMap.set(keyOf(r.dateTs,r.home_team,r.away_team), r);

    status.textContent="Calcolo tabelle spiegabili (solo match matchati)…";

    const xEdges=[2.5,3.0,3.5,4.0,5.0,6.0,7.0,8.0];
    const spEdges=[0.50,1.00,2.00,3.00,4.00,5.00,6.50];
    const gaEdges=[1.8,2.2,2.6,3.0,3.4,3.8];

    const aggX={}, aggSP={}, aggMU={}, aggXH={};
    let matched=0, overCnt=0;

    for(const q of quotes){
      const r=resMap.get(keyOf(q.dateTs,q.home_team,q.away_team));
      if(!r) continue;

      const hg=toNum(r.FTHG), ag=toNum(r.FTAG);
      if(!Number.isFinite(hg) || !Number.isFinite(ag)) continue;
      const isOver=(hg+ag)>=3;

      const odd1=toNum(q.b365_1), odd2=toNum(q.b365_2), oddX=toNum(q.b365_x);
      const spread=(Number.isFinite(odd1)&&Number.isFinite(odd2))?Math.abs(odd1-odd2):NaN;

      const est=estimateMu(results,q.home_team,q.away_team,N,q.dateTs);
      if(!Number.isFinite(est.mu)) continue;

      matched++; if(isOver) overCnt++;

      addAgg(aggX, binLabel(oddX,xEdges), isOver);
      addAgg(aggSP, binLabel(spread,spEdges), isOver);
      addAgg(aggMU, binLabel(est.mu,gaEdges), isOver);
      if(Number.isFinite(oddX) && oddX>=xHigh) addAgg(aggXH, binLabel(oddX,xEdges), isOver);
    }

    const baseOver = matched ? (overCnt/matched) : NaN;

    status.textContent="Selezione top…";
    const candidates=[];
    for(const q of quotes){
      if(resMap.has(keyOf(q.dateTs,q.home_team,q.away_team))) continue; // future
      const oddX=toNum(q.b365_x);
      const odd1=toNum(q.b365_1);
      const odd2=toNum(q.b365_2);
      const spread=(Number.isFinite(odd1)&&Number.isFinite(odd2))?Math.abs(odd1-odd2):NaN;

      const est=estimateMu(results,q.home_team,q.away_team,N,q.dateTs);
      if(!Number.isFinite(est.mu)) continue;

      let pO=pOver25(est.mu);
      if(!Number.isFinite(pO)) continue;
      pO = applyXBonus(pO, oddX, xHigh, xBoost, useXBonus);
      const pU=1-pO;

      let pick="OVER", pPick=pO;
      if(mode==="under"){ pick="UNDER"; pPick=pU; }
      else if(mode==="auto"){ if(pU>pO){ pick="UNDER"; pPick=pU; } }

      if(pPick < pMin) continue;

      const lift = Number.isFinite(baseOver) ? ((pick==="OVER") ? (pO-baseOver) : (pU-(1-baseOver))) : 0;
      const score = pPick + 0.35*lift;

      candidates.push({dateStr:q.dateStr, home:q.home_team, away:q.away_team, odd1, oddX, odd2, spread, mu:est.mu, pO, pU, pick, pPick, lift, score});
    }
    candidates.sort((a,b)=>b.score-a.score);
    const top=candidates.slice(0, topK);

    const topRows = top.map(x=>`
      <tr>
        <td><b>${x.home} — ${x.away}</b><br><small class="muted">${x.dateStr}</small></td>
        <td class="mono">${fmtNum(x.odd1)} / <b>${fmtNum(x.oddX)}</b> / ${fmtNum(x.odd2)}<br><small class="muted">spread=${fmtNum(x.spread)}</small></td>
        <td class="mono">mu=${x.mu.toFixed(2)}</td>
        <td><b>${x.pick}</b><br><small class="muted">P(Over) ${fmtPct(x.pO)} • P(Under) ${fmtPct(x.pU)}</small></td>
        <td><b>${fmtPct(x.pPick)}</b><br><small class="muted">lift ${fmtPct(x.lift)}</small></td>
      </tr>
    `).join("") || `<tr><td colspan="5" class="muted">Nessuna partita supera la soglia probabilità</td></tr>`;

    output.innerHTML = `
      <div class="card">
        <b>Baseline (solo match matchati quote+risultati)</b>
        <div class="row" style="margin-top:10px">
          <span class="pill"><b>Match matchati:</b> ${matched}</span>
          <span class="pill"><b>%Over (baseline):</b> ${Number.isFinite(baseOver)?(baseOver*100).toFixed(1)+"%":"—"}</span>
          <span class="pill"><b>%Under (baseline):</b> ${Number.isFinite(baseOver)?(100-baseOver*100).toFixed(1)+"%":"—"}</span>
        </div>
        <small class="muted" style="display:block;margin-top:8px">
          Le tabelle sotto rispondono al tuo “perché esce?”: mostrano <b>come cambia %Over</b> quando cambia X/spread/GA.
        </small>
      </div>

      ${makeTable("A) Over/Under per QUOTA X (b365_x)", aggToRows(aggX))}
      ${makeTable("B) Over/Under per SPREAD |1-2|", aggToRows(aggSP))}
      ${makeTable("C) Over/Under per GA (proxy mu totale da recenti)", aggToRows(aggMU))}
      ${makeTable("D) Over/Under SOLO dove X ≥ soglia (per vedere l’effetto X alta)", aggToRows(aggXH))}

      <div class="card">
        <b>Selezione pre-match (top ${topK})</b>
        <table>
          <thead>
            <tr><th>Match</th><th>Quote 1 / X / 2</th><th>GA (mu)</th><th>Probabilità stimate</th><th>Decisione</th></tr>
          </thead>
          <tbody>${topRows}</tbody>
        </table>
        <small class="muted" style="display:block;margin-top:8px">
          Senza quote Over/Under non faccio ROI: qui segnalo <b>solo</b> dove statisticamente Over/Under è più probabile.
        </small>
      </div>
    `;

    status.textContent="Completato ✅";
  }catch(e){
    status.textContent="Errore: " + (e?.message || e);
  }
}

/* 2) BACKTEST */
async function backtest(){
  const status=document.getElementById("status");
  const output=document.getElementById("output");
  status.textContent="BACKTEST: carico CSV…"; output.innerHTML="";
  try{
    const fRes=document.getElementById("csvResultsFile").files?.[0];
    const fQuo=document.getElementById("csvQuotesFile").files?.[0];
    if(!fRes || !fQuo){ status.textContent="⚠️ Seleziona entrambi i CSV."; return; }

    const N=+document.getElementById("N").value||12;
    const mode=document.getElementById("mode").value;
    const pMin=(+document.getElementById("pMin").value||60)/100;

    const useXBonus=(document.getElementById("useXBonus").value==="on");
    const xHigh=+document.getElementById("xHigh").value||4.0;
    const xBoost=+document.getElementById("xBoost").value||0.03;

    const resText=await readFileText(fRes);
    const quoText=await readFileText(fQuo);

    const results=parseCSV(resText).map(normResultRow).filter(r=>r.dateStr && r.home_team && r.away_team && Number.isFinite(r.dateTs));
    const quotes=parseCSV(quoText).map(normQuoteRow).filter(q=>q.dateStr && q.home_team && q.away_team && Number.isFinite(q.dateTs));

    const resMap=new Map();
    for(const r of results) resMap.set(keyOf(r.dateTs,r.home_team,r.away_team), r);

    const xEdges=[2.5,3.0,3.5,4.0,5.0,6.0,7.0,8.0];
    const spEdges=[0.50,1.00,2.00,3.00,4.00,5.00,6.50];
    const gaEdges=[1.8,2.2,2.6,3.0,3.4,3.8];

    let matched=0, notMatched=0;
    let taken=0, hit=0, miss=0;
    let takenOver=0, hitOver=0;
    let takenUnder=0, hitUnder=0;

    const takeByX={}, takeBySP={}, takeByMU={};

    status.textContent="BACKTEST: calcolo prese…";

    for(const q of quotes){
      const r=resMap.get(keyOf(q.dateTs,q.home_team,q.away_team));
      if(!r){ notMatched++; continue; }

      const hg=toNum(r.FTHG), ag=toNum(r.FTAG);
      if(!Number.isFinite(hg) || !Number.isFinite(ag)) continue;

      const isOver=(hg+ag)>=3;
      const isUnder=!isOver;

      const oddX=toNum(q.b365_x);
      const odd1=toNum(q.b365_1);
      const odd2=toNum(q.b365_2);
      const spread=(Number.isFinite(odd1)&&Number.isFinite(odd2))?Math.abs(odd1-odd2):NaN;

      const est=estimateMu(results,q.home_team,q.away_team,N,q.dateTs);
      if(!Number.isFinite(est.mu)) continue;

      matched++;

      let pO=pOver25(est.mu);
      if(!Number.isFinite(pO)) continue;
      pO = applyXBonus(pO, oddX, xHigh, xBoost, useXBonus);
      const pU=1-pO;

      let pick="OVER", pPick=pO;
      if(mode==="under"){ pick="UNDER"; pPick=pU; }
      else if(mode==="auto"){ if(pU>pO){ pick="UNDER"; pPick=pU; } }

      if(pPick < pMin) continue;

      taken++;

      addAgg(takeByX, binLabel(oddX,xEdges), isOver);
      addAgg(takeBySP, binLabel(spread,spEdges), isOver);
      addAgg(takeByMU, binLabel(est.mu,gaEdges), isOver);

      const win = (pick==="OVER" && isOver) || (pick==="UNDER" && isUnder);

      if(pick==="OVER") takenOver++;
      if(pick==="UNDER") takenUnder++;

      if(win){
        hit++;
        if(pick==="OVER") hitOver++;
        if(pick==="UNDER") hitUnder++;
      }else{
        miss++;
      }
    }

    const hitRate = taken ? (hit/taken) : NaN;

    output.innerHTML = `
      <div class="card">
        <b>BACKTEST – “quante partite ho preso pre-match” (senza quote U/O)</b>
        <div class="row" style="margin-top:10px">
          <span class="pill"><b>Match matchati:</b> ${matched}</span>
          <span class="pill"><b>Non matchati:</b> ${notMatched}</span>
          <span class="pill"><b>PRESE:</b> ${taken}</span>
          <span class="pill"><b>Hit:</b> ${hit}</span>
          <span class="pill"><b>Miss:</b> ${miss}</span>
          <span class="pill"><b>Hit-rate:</b> ${Number.isFinite(hitRate)?(hitRate*100).toFixed(1)+"%":"—"}</span>
        </div>

        <hr style="margin:12px 0">

        <div class="row">
          <span class="pill"><b>PRESE Over:</b> ${takenOver} (hit ${hitOver})</span>
          <span class="pill"><b>PRESE Under:</b> ${takenUnder} (hit ${hitUnder})</span>
          <span class="pill"><b>Soglia p:</b> ${(pMin*100).toFixed(0)}%</span>
          <span class="pill"><b>N recenti:</b> ${N}</span>
        </div>

        <small class="muted" style="display:block;margin-top:10px">
          Sotto vedi <b>dove</b> (quota X/spread/GA) le prese hanno più Over: è la risposta “perché esce”.
        </small>
      </div>

      ${makeTable("Prese – breakdown per QUOTA X (dentro alle prese)", aggToRows(takeByX))}
      ${makeTable("Prese – breakdown per SPREAD |1-2| (dentro alle prese)", aggToRows(takeBySP))}
      ${makeTable("Prese – breakdown per GA (mu) (dentro alle prese)", aggToRows(takeByMU))}
    `;

    status.textContent="BACKTEST completato ✅";
  }catch(e){
    status.textContent="Errore BACKTEST: " + (e?.message || e);
  }
}

document.getElementById("runBtn").addEventListener("click", run);
document.getElementById("btBtn").addEventListener("click", backtest);
</script>
</body>
</html>

<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Syncras – SOLO X (RECOVERY) + O/U 2.5 + Pari/Dispari</title>
<style>
  :root{--violet:#6C5CE7;--bg:#f7f7fb;--card:#fff;--border:#e7e7f5;--text:#111827;--muted:#6b7280}
  body{font-family:system-ui,Arial;margin:18px;background:var(--bg);color:var(--text)}
  h2{margin:0 0 10px 0}
  .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:14px;margin-top:14px}
  input,select,button{padding:9px;border-radius:12px;border:1px solid #cfcfe6}
  input[type="file"]{padding:10px}
  button{cursor:pointer;background:var(--violet);color:#fff;border:0;font-weight:900;padding:12px 14px;border-radius:14px}
  button:hover{filter:brightness(.96)}
  small{color:#555;line-height:1.35}
  .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
  .grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:10px}
  @media(max-width:820px){.grid{grid-template-columns:1fr}}
  .pill{display:inline-flex;gap:6px;align-items:center;border:1px solid var(--border);background:#fafafe;border-radius:999px;padding:6px 10px;font-size:12px;color:#555}
  table{border-collapse:collapse;width:100%;margin-top:12px;background:#fff;border:1px solid var(--border);border-radius:14px;overflow:hidden}
  th,td{border-bottom:1px solid #eee;padding:8px;text-align:right;font-size:13px;vertical-align:top}
  th{background:#fafafe;color:#333;font-size:12px}
  th:first-child,td:first-child{text-align:left}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .ok{color:#0a7} .bad{color:#c22} .warn{color:#d97706}
  .muted{color:var(--muted)}
</style>
</head>
<body>

<h2>Syncras – SOLO X (RECOVERY) + O/U 2.5 + Pari/Dispari</h2>
<div class="muted">
  Versione “RECOVERY”: meno muri → deve far uscire risultati. Poi stringiamo i cluster.<br>
  <small>Studio informativo. Nessun invito a scommettere.</small>
</div>

<div class="card">
  <div class="grid">
    <div>
      <label><b>CSV RISULTATI (storico)</b></label><br>
      <input id="csvResultsFile" type="file" accept=".csv,text/csv" style="width:100%">
      <small class="muted">Attesi: <span class="mono">date, home_team, away_team, result (1/X/2), FTHG, FTAG</span></small>
    </div>
    <div>
      <label><b>CSV QUOTE (future)</b></label><br>
      <input id="csvQuotesFile" type="file" accept=".csv,text/csv" style="width:100%">
      <small class="muted">Attesi: <span class="mono">date, home_team, away_team, b365_1, b365_x, b365_2</span> + opzionali O/U 2.5 + Pari/Dispari</small>
    </div>
    <div>
      <label><b>Comandi</b></label><br>
      <button id="runBtn" type="button">Trova partite (RECOVERY)</button>
      <div id="status" class="muted" style="margin-top:10px"></div>
    </div>
  </div>

  <hr style="margin:14px 0;border:none;border-top:1px solid #e9e9f7">

  <div class="row">
    <label>N (recenti)</label><input id="N" type="number" value="12" style="width:90px">
    <label>EV min (%)</label><input id="evMin" type="number" value="5" style="width:90px">
    <label>X min</label><input id="qMin" type="number" value="2.8" step="0.1" style="width:90px">
    <label>X max</label><input id="qMax" type="number" value="5.5" step="0.1" style="width:90px">
    <label>1 e 2 ≥</label><input id="odds12Min" type="number" value="1.55" step="0.01" style="width:90px">
    <label>Spread max</label><input id="spreadMax" type="number" value="3.5" step="0.1" style="width:90px">
    <label>GA max</label><input id="gaMax" type="number" value="1.35" step="0.05" style="width:90px">
    <label>Output</label><input id="topK" type="number" value="15" step="1" style="width:90px">
  </div>

  <div class="row" style="margin-top:10px">
    <label>Decay</label>
    <select id="decay">
      <option value="exp" selected>Esponenziale</option>
      <option value="linear">Lineare</option>
      <option value="none">Nessuno</option>
    </select>

    <label>GA agg</label>
    <select id="gaAgg">
      <option value="mean">Media</option>
      <option value="median">Mediana</option>
    </select>

    <span class="pill">Bootstrap: calcolato ma <b>non</b> blocca</span>
  </div>
</div>

<div id="output"></div>

<script>
/* ===== CSV robusto ===== */
function parseCSV(text){
  const rows=[]; let row=[], cur="", inQ=false;
  for(let i=0;i<text.length;i++){
    const ch=text[i], nx=text[i+1];
    if(ch === '"'){ if(inQ && nx === '"'){ cur+='"'; i++; } else inQ=!inQ; continue; }
    if(!inQ && (ch===',' || ch===';')){ row.push(cur); cur=""; continue; }
    if(!inQ && ch==='\n'){ row.push(cur); rows.push(row); row=[]; cur=""; continue; }
    if(!inQ && ch==='\r') continue;
    cur+=ch;
  }
  row.push(cur); rows.push(row);
  if(rows.length && rows[rows.length-1].every(c=>String(c).trim()==="")) rows.pop();
  const header=(rows[0]||[]).map(x=>String(x).trim());
  return rows.slice(1).map(r=>{
    const o={};
    for(let i=0;i<header.length;i++) o[header[i]] = String(r[i]??"").trim().replace(/"/g,"");
    return o;
  });
}
function normKey(s){ return String(s||"").trim().toLowerCase(); }
function pick(o, keys){
  const map={}; for(const k in o) map[normKey(k)] = o[k];
  for(const k of keys){
    const v = map[normKey(k)];
    if(v!==undefined && String(v).trim()!=="") return v;
  }
  return undefined;
}
function toNum(x){
  const s=String(x??"").trim().replace(",",".");
  const n=Number(s);
  return Number.isFinite(n) ? n : NaN;
}
function parseDateTs(s){
  const t = String(s ?? "").trim();
  if(!t) return NaN;
  if(/^\d{4}-\d{2}-\d{2}$/.test(t)) return Date.parse(t + "T00:00:00Z");
  let m=t.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
  if(m){
    const dd=+m[1], mm=+m[2], yyyy=+m[3];
    const iso=${yyyy}-${String(mm).padStart(2,'0')}-${String(dd).padStart(2,'0')};
    return Date.parse(iso+"T00:00:00Z");
  }
  m=t.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2})$/);
  if(m){
    const dd=+m[1], mm=+m[2], yy=+m[3];
    const yyyy=(yy>=70)?(1900+yy):(2000+yy);
    const iso=${yyyy}-${String(mm).padStart(2,'0')}-${String(dd).padStart(2,'0')};
    return Date.parse(iso+"T00:00:00Z");
  }
  const x=Date.parse(t);
  return Number.isFinite(x) ? x : NaN;
}
async function readFileText(file){
  return new Promise((res,rej)=>{
    const r=new FileReader();
    r.onload=()=>res(String(r.result||""));
    r.onerror=rej;
    r.readAsText(file);
  });
}
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function fmtNum(x){ return Number.isFinite(x) ? x.toFixed(2) : "—"; }
function fmtPct01(x){ return Number.isFinite(x) ? (x*100).toFixed(1)+"%" : "—"; }
function normTeam(s){ return String(s||"").trim().toLowerCase(); }

/* ===== normalize ===== */
function normResultRow(o){
  const dateStr = String(pick(o,["date","match_date","data","giorno","Date","DATA"])||"").trim();
  const home_team = normTeam(pick(o,["home_team","hometeam","home","HomeTeam","CASA"])||"");
  const away_team = normTeam(pick(o,["away_team","awayteam","away","AwayTeam","TRASFERTA"])||"");
  let result = String(pick(o,["result","Result","FTR","esito","ft"])||"").trim().toUpperCase();
  if(result==="D") result="X"; if(result==="H") result="1"; if(result==="A") result="2";
  const FTHG = pick(o,["FTHG","fthg","hg","home_goals","HomeGoals"]) ?? "";
  const FTAG = pick(o,["FTAG","ftag","ag","away_goals","AwayGoals"]) ?? "";
  const dateTs = parseDateTs(dateStr);
  return {dateStr, dateTs, home_team, away_team, result, FTHG:String(FTHG).trim(), FTAG:String(FTAG).trim()};
}
function normQuoteRow(o){
  const dateStr = String(pick(o,["date","match_date","data","giorno","Date","DATA"])||"").trim();
  const home_team = normTeam(pick(o,["home_team","hometeam","home","HomeTeam","CASA"])||"");
  const away_team = normTeam(pick(o,["away_team","awayteam","away","AwayTeam","TRASFERTA"])||"");
  const dateTs = parseDateTs(dateStr);

  const b365_x = pick(o,["b365_x","B365D","oddx","odds_x","X","draw"]) ?? "";
  const b365_1 = pick(o,["b365_1","b365_h","B365H","odd1","odds_1","1","home"]) ?? "";
  const b365_2 = pick(o,["b365_2","b365_a","B365A","odd2","odds_2","2","away"]) ?? "";

  const o25 = pick(o,["b365_o25","B365O25","B365O2.5","B365>2.5","O25","over25","Over2.5"]) ?? "";
  const u25 = pick(o,["b365_u25","B365U25","B365U2.5","B365<2.5","U25","under25","Under2.5"]) ?? "";

  const even = pick(o,["b365_even","B365Even","even","pari","Even","PARI","odds_even"]) ?? "";
  const odd = pick(o,["b365_odd","B365Odd","odd","dispari","Odd","DISPARI","odds_odd"]) ?? "";

  return {dateStr, dateTs, home_team, away_team,
    b365_x:String(b365_x).trim(), b365_1:String(b365_1).trim(), b365_2:String(b365_2).trim(),
    o25:String(o25).trim(), u25:String(u25).trim(), even:String(even).trim(), odd:String(odd).trim()
  };
}
function isPlayed(r){ return (r.result==="1"||r.result==="X"||r.result==="2"); }

/* ===== Draw rate ===== */
function weights(n, mode){
  if(mode==="none") return Array.from({length:n}, ()=>1);
  if(mode==="linear") return Array.from({length:n}, (_,i)=>i+1);
  return Array.from({length:n}, (_,i)=>Math.pow(1.5, i));
}
function resultForTeam(team,r){
  if(r.result==="X") return "D";
  if(r.result==="1") return r.home_team===team?"W":"L";
  if(r.result==="2") return r.away_team===team?"W":"L";
  return "";
}
function weightedRateDraw(team, matches, mode){
  if(matches.length===0) return 0;
  const w=weights(matches.length, mode);
  let num=0, den=0;
  for(let i=0;i<matches.length;i++){
    const r=matches[i];
    const isD = (resultForTeam(team,r)==="D") ? 1 : 0;
    num += isD * w[i];
    den += w[i];
  }
  return den ? num/den : 0;
}
function calcPX(results, match, N, decayMode){
  const prev = results.filter(x => isPlayed(x) && Number.isFinite(x.dateTs) && x.dateTs < match.dateTs);

  const homeHist = prev.filter(x=>x.home_team===match.home_team);
  const awayHist = prev.filter(x=>x.away_team===match.away_team);
  const hX = homeHist.filter(x=>x.result==="X").length / (homeHist.length||1);
  const aX = awayHist.filter(x=>x.result==="X").length / (awayHist.length||1);
  const histPX = (hX + aX) / 2;

  const sortedPrev = prev.slice().sort((a,b)=>b.dateTs - a.dateTs);
  const homeRecent = sortedPrev.filter(x=>x.home_team===match.home_team || x.away_team===match.home_team).slice(0,N).reverse();
  const awayRecent = sortedPrev.filter(x=>x.home_team===match.away_team || x.away_team===match.away_team).slice(0,N).reverse();

  const recPX = (weightedRateDraw(match.home_team, homeRecent, decayMode) +
                 weightedRateDraw(match.away_team, awayRecent, decayMode))/2;

  return clamp(0.6*recPX + 0.4*histPX, 0.10, 0.60);
}

/* ===== GA conceded ===== */
function median(arr){
  const a=arr.slice().sort((x,y)=>x-y);
  const n=a.length; if(!n) return NaN;
  const mid=Math.floor(n/2);
  return n%2 ? a[mid] : (a[mid-1]+a[mid])/2;
}
function teamRecentConceded(results, team, N, dateTs){
  const prev = results
    .filter(x => isPlayed(x) && Number.isFinite(x.dateTs) && x.dateTs < dateTs &&
                 (x.home_team===team || x.away_team===team))
    .sort((a,b)=>a.dateTs - b.dateTs)
    .slice(-N);

  const out=[];
  for(const m of prev){
    const hg = toNum(m.FTHG);
    const ag = toNum(m.FTAG);
    if(!Number.isFinite(hg) || !Number.isFinite(ag)) continue;
    const conceded = (m.home_team===team) ? ag : hg;
    out.push(conceded);
  }
  return out;
}

/* ===== bootstrap (solo info) ===== */
function percentile(sortedArr, p){
  if(sortedArr.length===0) return NaN;
  const idx=(sortedArr.length-1)*p;
  const lo=Math.floor(idx), hi=Math.ceil(idx);
  if(lo===hi) return sortedArr[lo];
  return sortedArr[lo] + (sortedArr[hi]-sortedArr[lo])*(idx-lo);
}
function bootstrapPX(results, match, N, decayMode, B){
  const prevAll = results.filter(x => isPlayed(x) && Number.isFinite(x.dateTs) && x.dateTs < match.dateTs);
  if(prevAll.length < 30) return {p05:NaN, med:NaN, p95:NaN};

  const sample=(arr,k)=> {
    const out=[];
    for(let i=0;i<k;i++) out.push(arr[Math.floor(Math.random()*arr.length)]);
    return out;
  };

  const hAll = prevAll.filter(x=>x.home_team===match.home_team || x.away_team===match.home_team);
  const aAll = prevAll.filter(x=>x.home_team===match.away_team || x.away_team===match.away_team);

  const vals=[];
  const hK=Math.max(10, Math.min(hAll.length, 60));
  const aK=Math.max(10, Math.min(aAll.length, 60));

  for(let i=0;i<B;i++){
    const mix = []
      .concat(sample(hAll, hK))
      .concat(sample(aAll, aK))
      .concat(sample(prevAll, Math.min(prevAll.length, 100)));
    mix.sort((x,y)=>x.dateTs - y.dateTs);
    vals.push(calcPX(mix, match, N, decayMode));
  }
  vals.sort((x,y)=>x-y);
  return { p05: percentile(vals,0.05), med: percentile(vals,0.50), p95: percentile(vals,0.95) };
}

function ev(pX, oddX){ return pX*oddX - 1; }

/* ===== MAIN ===== */
async function run(){
  const status = document.getElementById("status");
  const output = document.getElementById("output");
  status.textContent="Carico CSV…";
  output.innerHTML="";

  const fRes = document.getElementById("csvResultsFile").files?.[0];
  const fQuo = document.getElementById("csvQuotesFile").files?.[0];
  if(!fRes || !fQuo){ status.textContent="⚠️ Seleziona entrambi i CSV."; return; }

  const resText = await readFileText(fRes);
  const quoText = await readFileText(fQuo);

  const results = parseCSV(resText).map(normResultRow)
    .filter(r=>r.dateStr && r.home_team && r.away_team && Number.isFinite(r.dateTs));

  const quotes = parseCSV(quoText).map(normQuoteRow)
    .filter(q=>q.dateStr && q.home_team && q.away_team && Number.isFinite(q.dateTs));

  const N=+document.getElementById("N").value||12;
  const evMin=(+document.getElementById("evMin").value||5)/100;
  const qMin=+document.getElementById("qMin").value||2.8;
  const qMax=+document.getElementById("qMax").value||5.5;
  const odds12Min=+document.getElementById("odds12Min").value||1.55;
  const spreadMax=+document.getElementById("spreadMax").value||3.5;
  const gaMax=+document.getElementById("gaMax").value||1.35;
  const topK=Math.max(1,+document.getElementById("topK").value||15);
  const decayMode=document.getElementById("decay").value;
  const gaAgg=document.getElementById("gaAgg").value;
  const B=600; // info-only

  status.textContent="Calcolo…";

  let checked=0, kept=0, skipOdds=0, skipSpread=0, skipPX=0, skipEV=0;

  const list=[];
  for(const q of quotes){
    checked++;

    const oddX=toNum(q.b365_x);
    const odd1=toNum(q.b365_1);
    const odd2=toNum(q.b365_2);

    if(!Number.isFinite(oddX) || oddX<qMin || oddX>qMax){ skipOdds++; continue; }
    if(!Number.isFinite(odd1) || !Number.isFinite(odd2) || odd1<odds12Min || odd2<odds12Min){ skipOdds++; continue; }

    const spread12=Math.abs(odd1-odd2);
    if(!Number.isFinite(spread12) || spread12>spreadMax){ skipSpread++; continue; }

    const match={dateTs:q.dateTs, dateStr:q.dateStr, home_team:q.home_team, away_team:q.away_team};

    const pX=calcPX(results, match, N, decayMode);
    if(!Number.isFinite(pX) || pX<=0){ skipPX++; continue; }

    const EV=ev(pX, oddX);
    if(EV<evMin){ skipEV++; continue; }

    // GA (NON blocca se non disponibile)
    const gaH=teamRecentConceded(results, match.home_team, N, match.dateTs);
    const gaA=teamRecentConceded(results, match.away_team, N, match.dateTs);
    const agg = (arr)=> gaAgg==="median" ? median(arr) : (arr.reduce((s,v)=>s+v,0)/arr.length);
    const gaHn = gaH.length>=3 ? agg(gaH) : NaN;
    const gaAn = gaA.length>=3 ? agg(gaA) : NaN;

    // se GA disponibile e supera gaMax, scarta (muro leggero)
    if(Number.isFinite(gaHn) && gaHn>gaMax) continue;
    if(Number.isFinite(gaAn) && gaAn>gaMax) continue;

    // bootstrap info
    const ci=bootstrapPX(results, match, N, decayMode, B);
    const width=(Number.isFinite(ci.p95)&&Number.isFinite(ci.p05)) ? (ci.p95-ci.p05) : NaN;

    kept++;
    list.push({
      match, odd1, oddX, odd2, spread12,
      pX, EV, implied:1/oddX,
      ci, width,
      gaHn, gaAn,
      o25:toNum(q.o25), u25:toNum(q.u25),
      even:toNum(q.even), odd:toNum(q.odd)
    });
  }

  list.sort((a,b)=>b.EV-a.EV);
  const top=list.slice(0, topK);

  if(!top.length){
    status.textContent="0 risultati (anche in RECOVERY).";
    output.innerHTML = `
      <div class="card">
        <b>Diagnostica</b><br>
        <div class="row" style="margin-top:10px">
          <span class="pill"><b>Quote lette:</b> ${quotes.length}</span>
          <span class="pill"><b>Analizzate:</b> ${checked}</span>
          <span class="pill"><b>Skip odds:</b> ${skipOdds}</span>
          <span class="pill"><b>Skip spread:</b> ${skipSpread}</span>
          <span class="pill"><b>Skip pX:</b> ${skipPX}</span>
          <span class="pill"><b>Skip EV:</b> ${skipEV}</span>
        </div>
        <small class="muted" style="display:block;margin-top:10px">
          Se “Skip odds” è alto → il CSV quote non ha b365_1/b365_x/b365_2 come li stiamo leggendo (nomi colonne diversi).<br>
          Se “Skip spread” è alto → spreadMax troppo basso.<br>
          Se “Skip pX” è alto → date delle quote non parse / non ci sono risultati precedenti (dateTs sbagliata).<br>
          Se “Skip EV” è alto → EV min troppo alto.
        </small>
      </div>`;
    return;
  }

  const rows=top.map(x=>`
    <tr>
      <td><b>${x.match.home_team} — ${x.match.away_team}</b><br><small class="muted">${x.match.dateStr}</small></td>
      <td class="mono">${fmtNum(x.odd1)} / <b>${fmtNum(x.oddX)}</b> / ${fmtNum(x.odd2)}<br><small class="muted">spread=${fmtNum(x.spread12)}</small></td>
      <td><b>${fmtPct01(x.pX)}</b><br><small class="muted">implied ${fmtPct01(x.implied)}</small></td>
      <td class="${x.EV>=0.25?'ok':(x.EV>=0.15?'warn':'')}"><b>${(x.EV*100>=0?"+":"")}${(x.EV*100).toFixed(1)}%</b></td>
      <td class="mono">${fmtPct01(x.ci.p05)}–${fmtPct01(x.ci.p95)}<br><small class="muted">w=${fmtNum(x.width)}</small></td>
      <td><small>GA(H)=${fmtNum(x.gaHn)} • GA(A)=${fmtNum(x.gaAn)}<br>O2.5=${fmtNum(x.o25)} U2.5=${fmtNum(x.u25)}<br>Pari=${fmtNum(x.even)} Dispari=${fmtNum(x.odd)}</small></td>
    </tr>
  `).join("");

  output.innerHTML=`
    <div class="card">
      <div class="row">
        <span class="pill"><b>Risultati:</b> ${results.length}</span>
        <span class="pill"><b>Quote:</b> ${quotes.length}</span>
        <span class="pill"><b>Tenute:</b> ${kept}</span>
      </div>
      <table>
        <thead>
          <tr>
            <th>Match</th><th>1/X/2</th><th>P(X)</th><th>EV</th><th>CI (info)</th><th>Extra (info)</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
    </div>
  `;
  status.textContent="Completato ✅";
}

document.getElementById("runBtn").addEventListener("click", run);
</script>

</body>
</html>


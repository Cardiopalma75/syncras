<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Syncras — Backtest GG/NG (Serie A e leghe) con CSV risultati + quote</title>
  <style>
    :root{
      --bg:#0b0b12; --card:#121225; --muted:#a7a7c2; --txt:#f2f2ff;
      --accent:#8b5cf6; --ok:#22c55e; --warn:#f59e0b; --bad:#ef4444;
      --border: rgba(255,255,255,.10);
    }
    body{margin:0;background:linear-gradient(180deg,#07070f 0%,#0b0b12 100%);color:var(--txt);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif}
    .wrap{max-width:1200px;margin:0 auto;padding:18px}
    h1{font-size:20px;margin:6px 0 12px}
    h2{font-size:16px;margin:18px 0 10px}
    .card{background:rgba(18,18,37,.92);border:1px solid var(--border);border-radius:14px;padding:14px;
      box-shadow:0 12px 30px rgba(0,0,0,.35)}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .col{flex:1;min-width:300px}
    label{display:block;font-size:12px;color:var(--muted);margin:8px 0 6px}
    input[type="file"], select, input[type="number"], input[type="text"]{
      width:100%;padding:10px;border-radius:12px;border:1px solid var(--border);
      background:#0f0f20;color:var(--txt);outline:none
    }
    button{
      padding:10px 12px;border-radius:12px;border:1px solid var(--border);
      background:linear-gradient(180deg,rgba(139,92,246,.95),rgba(139,92,246,.75));
      color:white;cursor:pointer;font-weight:800
    }
    button:disabled{opacity:.55;cursor:not-allowed}
    .muted{color:var(--muted);font-size:13px;line-height:1.35}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:5px 10px;border-radius:999px;border:1px solid var(--border);font-size:12px}
    .pill.ok{background:rgba(34,197,94,.14);border-color:rgba(34,197,94,.35)}
    .pill.bad{background:rgba(239,68,68,.14);border-color:rgba(239,68,68,.35)}
    .pill.warn{background:rgba(245,158,11,.14);border-color:rgba(245,158,11,.35)}
    .pill.neutral{background:rgba(255,255,255,.06)}
    .hr{height:1px;background:var(--border);margin:14px 0}
    table{width:100%;border-collapse:collapse}
    th,td{padding:9px 8px;border-bottom:1px solid var(--border);text-align:left;font-size:13px;white-space:nowrap}
    th{color:#d9d9ff;font-weight:900;position:sticky;top:0;background:#121225;z-index:1}
    tr:hover td{background:rgba(255,255,255,.03)}
    .small{font-size:12px;color:var(--muted)}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .grid3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px}
    @media (max-width:900px){.grid3{grid-template-columns:1fr}}
    @media (max-width:720px){.grid2{grid-template-columns:1fr}}
    .kpi{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
    .kpi .box{flex:1;min-width:170px;background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:12px;padding:10px}
    .kpi .v{font-size:18px;font-weight:950}
    .kpi .t{font-size:12px;color:var(--muted)}
    .note{font-size:12px;color:var(--muted);margin-top:10px}
    a{color:#c4b5fd}
  </style>
</head>
<body>
<div class="wrap">
  <h1>Syncras — Backtest Gol/NoGol (GG/NG) con CSV risultati + CSV quote</h1>

  <div class="card">
    <div class="muted">
      Questo strumento è <b>solo analisi statistica</b> e backtest storico. Non è un invito a scommettere.
      I risultati passati non garantiscono risultati futuri. Usa sempre responsabilità e limiti.
    </div>
  </div>

  <div class="row" style="margin-top:12px">
    <div class="col card">
      <h2>1) CSV Risultati (storico)</h2>
      <label>Carica CSV risultati</label>
      <input id="resultsFile" type="file" accept=".csv,text/csv" />

      <div class="hr"></div>

      <div class="grid2">
        <div>
          <label>Separatore</label>
          <select id="r_sep">
            <option value="auto">Auto</option>
            <option value=",">,</option>
            <option value=";">;</option>
            <option value="\t">TAB</option>
          </select>
        </div>
        <div>
          <label>Preset rapido (per il tuo results_unified.csv)</label>
          <select id="preset">
            <option value="auto">Auto</option>
            <option value="results_unified">results_unified (date, league, home_team, away_team, FTHG, FTAG)</option>
          </select>
        </div>
      </div>

      <div class="grid3" style="margin-top:8px">
        <div><label>date</label><select id="r_date"></select></div>
        <div><label>league</label><select id="r_league"></select></div>
        <div><label>home_team</label><select id="r_home"></select></div>
        <div><label>away_team</label><select id="r_away"></select></div>
        <div><label>FTHG</label><select id="r_hg"></select></div>
        <div><label>FTAG</label><select id="r_ag"></select></div>
      </div>

      <div style="margin-top:10px;display:flex;gap:10px;flex-wrap:wrap">
        <button id="btnPrepare" disabled>Prepara dataset (pulizia + ordinamento)</button>
      </div>

      <div class="note" id="resultsStatus"></div>
    </div>

    <div class="col card">
      <h2>2) CSV Quote (GG/NG)</h2>
      <label>Carica CSV quote</label>
      <input id="oddsFile" type="file" accept=".csv,text/csv" />

      <div class="hr"></div>

      <div class="grid2">
        <div>
          <label>Separatore</label>
          <select id="o_sep">
            <option value="auto">Auto</option>
            <option value=",">,</option>
            <option value=";">;</option>
            <option value="\t">TAB</option>
          </select>
        </div>
        <div>
          <label>Nota</label>
          <div class="small">Devi avere almeno una quota: <b>GG</b> oppure <b>NG</b> (o entrambe).</div>
        </div>
      </div>

      <div class="grid3" style="margin-top:8px">
        <div><label>date</label><select id="o_date"></select></div>
        <div><label>league</label><select id="o_league"></select></div>
        <div><label>home_team</label><select id="o_home"></select></div>
        <div><label>away_team</label><select id="o_away"></select></div>
        <div><label>Quota GG (BTTS Yes)</label><select id="o_gg"></select></div>
        <div><label>Quota NG (BTTS No)</label><select id="o_ng"></select></div>
      </div>

      <div style="margin-top:10px;display:flex;gap:10px;flex-wrap:wrap">
        <button id="btnBacktest" disabled>BACKTEST</button>
        <button id="btnExportBets" disabled>Esporta bets (CSV)</button>
      </div>

      <div class="note" id="oddsStatus"></div>
    </div>
  </div>

  <div class="card" style="margin-top:12px">
    <h2>3) Parametri Backtest</h2>
    <div class="grid3">
      <div>
        <label>Mercato da testare</label>
        <select id="market">
          <option value="NG">NO GOL (BTTS No)</option>
          <option value="GG">GOL (BTTS Yes)</option>
        </select>
      </div>
      <div>
        <label>Lookback lega (quante partite precedenti usare)</label>
        <input id="lookback" type="number" min="50" step="10" value="380" />
        <div class="small">Esempio: 380 ≈ una stagione. Più alto = più stabile.</div>
      </div>
      <div>
        <label>Soglia EV minima (in %)</label>
        <input id="minEV" type="number" step="1" value="5" />
        <div class="small">Esempio: 5 = prendo solo EV ≥ +5%.</div>
      </div>

      <div>
        <label>Puntata fissa per bet</label>
        <input id="stake" type="number" min="1" step="1" value="10" />
      </div>
      <div>
        <label>Filtro lega (vuoto = tutte)</label>
        <input id="leagueFilter" type="text" placeholder="Es: I1 (Serie A) oppure D1..." />
      </div>
      <div>
        <label>Range date (opzionale)</label>
        <input id="dateFrom" type="text" placeholder="YYYY-MM-DD (da)" />
        <input id="dateTo" type="text" placeholder="YYYY-MM-DD (a)" style="margin-top:8px" />
      </div>
    </div>

    <div class="note">
      Logica: per ogni match, stimiamo P(GG)/P(NG) dalla <b>stessa lega</b> usando solo partite <b>prima</b> della data match.
      Se la quota del mercato scelto è presente, calcoliamo EV = p*quota - 1. Se EV ≥ soglia → “bet”.
    </div>
  </div>

  <div class="card" style="margin-top:12px">
    <h2>Risultati Backtest</h2>
    <div id="kpis" class="kpi" style="display:none"></div>
    <div class="note" id="btNote"></div>
  </div>

  <div class="card" style="margin-top:12px">
    <h2>Lista Bets</h2>
    <div style="overflow:auto;max-height:560px;margin-top:10px">
      <table id="betsTable">
        <thead>
          <tr>
            <th>Data</th>
            <th>Lega</th>
            <th>Match</th>
            <th>Mercato</th>
            <th>P stimata</th>
            <th>Quota</th>
            <th>EV</th>
            <th>Esito reale</th>
            <th>Profitto</th>
            <th>Bankroll (cum)</th>
            <th>Lookback N</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <div class="note">Profitto calcolato con puntata fissa: se vince → (quota-1)*stake, se perde → -stake.</div>
  </div>
</div>

<script>
/* ============ CSV parser ============ */
function detectSeparator(text){
  const sample = text.slice(0, 4000);
  const candidates = [",",";","\t"];
  let best = ",", bestScore = -1;
  for (const sep of candidates){
    const lines = sample.split(/\r?\n/).slice(0, 30).filter(Boolean);
    let score = 0;
    for (const line of lines){
      score += (line.match(new RegExp(sep.replace("\t","\\t"), "g")) || []).length;
    }
    if (score > bestScore){ bestScore = score; best = sep; }
  }
  return best;
}

function parseCSV(text, sep){
  if (sep === "auto") sep = detectSeparator(text);
  const rows = [];
  let i=0, field="", row=[], inQuotes=false;
  function pushField(){ row.push(field); field=""; }
  function pushRow(){
    const allEmpty = row.every(v => String(v).trim()==="");
    if (!allEmpty) rows.push(row);
    row=[];
  }
  while (i < text.length){
    const c = text[i];
    if (c === '"'){
      if (inQuotes && text[i+1] === '"'){ field+='"'; i+=2; continue; }
      inQuotes = !inQuotes; i++; continue;
    }
    if (!inQuotes && c === sep){ pushField(); i++; continue; }
    if (!inQuotes && (c === "\n" || c === "\r")){
      if (c === "\r" && text[i+1] === "\n") i++;
      pushField(); pushRow(); i++; continue;
    }
    field += c; i++;
  }
  pushField(); pushRow();
  const headers = (rows.shift() || []).map(h => String(h).trim());
  const outRows = rows.map(r => {
    const obj = {};
    for (let k=0;k<headers.length;k++) obj[headers[k]] = (r[k] ?? "").toString().trim();
    return obj;
  });
  return { headers, rows: outRows, sep };
}

/* ============ helpers ============ */
const $ = (id) => document.getElementById(id);

function toNumber(x){
  const s = String(x ?? "").trim().replace(",", ".");
  const n = Number(s);
  return Number.isFinite(n) ? n : NaN;
}

function parseDateAny(s){
  if (!s) return null;
  const t = String(s).trim();
  let m = t.match(/^(\d{4})[-/](\d{1,2})[-/](\d{1,2})/);
  if (m){
    const y=+m[1], mo=+m[2]-1, d=+m[3];
    const dt = new Date(Date.UTC(y,mo,d));
    return isNaN(dt.getTime()) ? null : dt;
  }
  m = t.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/);
  if (m){
    const d=+m[1], mo=+m[2]-1, y=+m[3];
    const dt = new Date(Date.UTC(y,mo,d));
    return isNaN(dt.getTime()) ? null : dt;
  }
  const dt = new Date(t);
  return isNaN(dt.getTime()) ? null : dt;
}

function pct(x){ return (x*100).toFixed(1) + "%"; }
function fmt(x,d=2){ return Number.isFinite(x) ? x.toFixed(d) : ""; }

function fillSelect(sel, headers, includeEmpty=false){
  sel.innerHTML = "";
  if (includeEmpty){
    const o = document.createElement("option");
    o.value = "";
    o.textContent = "(nessuna)";
    sel.appendChild(o);
  }
  for (const h of headers){
    const o = document.createElement("option");
    o.value = h;
    o.textContent = h;
    sel.appendChild(o);
  }
}

function downloadCSV(filename, headerArr, rowsArr){
  const esc = (v) => {
    const s = (v === null || v === undefined) ? "" : String(v);
    if (s.includes('"') || s.includes(",") || s.includes(";") || s.includes("\n") || s.includes("\r")){
      return '"' + s.replaceAll('"','""') + '"';
    }
    return s;
  };
  const lines = [];
  lines.push(headerArr.map(esc).join(","));
  for (const r of rowsArr){
    lines.push(headerArr.map(h => esc(r[h])).join(","));
  }
  const blob = new Blob([lines.join("\n")], {type:"text/csv;charset=utf-8"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}

/* ============ state ============ */
let R = { headers:[], rows:[], sep:",", clean:[], byLeagueSorted:new Map(), map:null, ready:false };
let O = { headers:[], rows:[], sep:",", map:null, loaded:false };
let bets = [];

/* ============ load results ============ */
$("resultsFile").addEventListener("change", async (e) => {
  const f = e.target.files?.[0];
  if (!f) return;
  const text = await f.text();
  const sep = $("r_sep").value;
  R = { ...R, ...parseCSV(text, sep), clean:[], byLeagueSorted:new Map(), ready:false };
  fillSelect($("r_date"), R.headers);
  fillSelect($("r_league"), R.headers);
  fillSelect($("r_home"), R.headers);
  fillSelect($("r_away"), R.headers);
  fillSelect($("r_hg"), R.headers);
  fillSelect($("r_ag"), R.headers);

  // preset for your unified file
  if ($("preset").value === "results_unified"){
    $("r_date").value = "date";
    $("r_league").value = "league";
    $("r_home").value = "home_team";
    $("r_away").value = "away_team";
    $("r_hg").value = "FTHG";
    $("r_ag").value = "FTAG";
  }

  $("resultsStatus").textContent = `Caricato risultati: ${R.rows.length} righe. Separatore: ${R.sep === "\t" ? "TAB" : R.sep}`;
  $("btnPrepare").disabled = R.rows.length === 0;
});

$("preset").addEventListener("change", () => {
  if ($("preset").value === "results_unified" && R.headers.length){
    $("r_date").value = "date";
    $("r_league").value = "league";
    $("r_home").value = "home_team";
    $("r_away").value = "away_team";
    $("r_hg").value = "FTHG";
    $("r_ag").value = "FTAG";
  }
});

/* ============ load odds ============ */
$("oddsFile").addEventListener("change", async (e) => {
  const f = e.target.files?.[0];
  if (!f) return;
  const text = await f.text();
  const sep = $("o_sep").value;
  O = { ...O, ...parseCSV(text, sep), loaded:true };
  fillSelect($("o_date"), O.headers);
  fillSelect($("o_league"), O.headers);
  fillSelect($("o_home"), O.headers);
  fillSelect($("o_away"), O.headers);
  fillSelect($("o_gg"), O.headers, true);
  fillSelect($("o_ng"), O.headers, true);

  $("oddsStatus").textContent = `Caricato quote: ${O.rows.length} righe. Separatore: ${O.sep === "\t" ? "TAB" : O.sep}`;
  $("btnBacktest").disabled = !(O.rows.length && R.ready);
});

/* ============ prepare results ============ */
$("btnPrepare").addEventListener("click", () => {
  try{
    const map = {
      date: $("r_date").value,
      league: $("r_league").value,
      home: $("r_home").value,
      away: $("r_away").value,
      hg: $("r_hg").value,
      ag: $("r_ag").value
    };
    for (const k of Object.keys(map)){
      if (!map[k]) throw new Error(`Mappatura risultati mancante: ${k}`);
    }
    R.map = map;

    const clean = [];
    for (const r of R.rows){
      const dt = parseDateAny(r[map.date]);
      const league = String(r[map.league] ?? "").trim();
      const home = String(r[map.home] ?? "").trim();
      const away = String(r[map.away] ?? "").trim();
      const hg = toNumber(r[map.hg]);
      const ag = toNumber(r[map.ag]);
      if (!dt || !league || !home || !away || !Number.isFinite(hg) || !Number.isFinite(ag)) continue;
      clean.push({ dt, league, home, away, hg, ag });
    }
    // group + sort by date within league
    const by = new Map();
    for (const m of clean){
      if (!by.has(m.league)) by.set(m.league, []);
      by.get(m.league).push(m);
    }
    for (const [lg, arr] of by.entries()){
      arr.sort((a,b)=>a.dt-b.dt);
    }
    R.clean = clean;
    R.byLeagueSorted = by;
    R.ready = true;

    $("resultsStatus").innerHTML = `<span class="pill ok">OK</span> Risultati pronti: ${clean.length} righe valide, ${by.size} leghe.`;
    $("btnBacktest").disabled = !(O.rows.length && R.ready);
  } catch(err){
    $("resultsStatus").innerHTML = `<span class="pill bad">ERRORE</span> ${err.message}`;
  }
});

/* ============ probability from lookback ============ */
function leagueProb(league, dt, lookback){
  const arr = R.byLeagueSorted.get(league);
  if (!arr || !arr.length) return null;

  // binary search first index >= dt
  let lo=0, hi=arr.length;
  while (lo < hi){
    const mid = (lo+hi)>>1;
    if (arr[mid].dt < dt) lo = mid+1;
    else hi = mid;
  }
  const end = lo; // strictly before dt
  const start = Math.max(0, end - lookback);
  const slice = arr.slice(start, end);
  if (slice.length < Math.min(50, lookback)) return null;

  let gg=0, ng=0;
  for (const m of slice){
    if (m.hg > 0 && m.ag > 0) gg++; else ng++;
  }
  const n = slice.length;
  return { n, pGG: gg/n, pNG: ng/n };
}

/* ============ backtest ============ */
$("btnBacktest").addEventListener("click", () => {
  try{
    if (!R.ready) throw new Error("Prepara prima il dataset risultati.");

    const map = {
      date: $("o_date").value,
      league: $("o_league").value,
      home: $("o_home").value,
      away: $("o_away").value,
      gg: $("o_gg").value || null,
      ng: $("o_ng").value || null
    };
    for (const k of ["date","league","home","away"]){
      if (!map[k]) throw new Error(`Mappatura quote mancante: ${k}`);
    }
    O.map = map;

    const market = $("market").value; // "GG" or "NG"
    const lookback = Math.max(50, toNumber($("lookback").value) || 380);
    const minEV = (toNumber($("minEV").value) || 0) / 100;
    const stake = Math.max(1, toNumber($("stake").value) || 10);
    const lf = String($("leagueFilter").value || "").trim();
    const dFrom = parseDateAny($("dateFrom").value) || null;
    const dTo = parseDateAny($("dateTo").value) || null;

    // build a fast lookup for results by key
    const resIndex = new Map();
    for (const m of R.clean){
      const key = `${m.dt.toISOString().slice(0,10)}|${m.league}|${m.home}|${m.away}`;
      resIndex.set(key, m);
    }

    bets = [];
    let scanned=0, joined=0, chosen=0, skippedNoOdds=0, skippedNoHist=0, skippedNoRes=0, skippedFilter=0;

    for (const r of O.rows){
      scanned++;
      const dt = parseDateAny(r[map.date]);
      if (!dt) continue;
      const dateKey = dt.toISOString().slice(0,10);

      const league = String(r[map.league] ?? "").trim();
      const home = String(r[map.home] ?? "").trim();
      const away = String(r[map.away] ?? "").trim();
      if (!league || !home || !away) continue;

      if (lf && league !== lf){ skippedFilter++; continue; }
      if (dFrom && dt < dFrom){ skippedFilter++; continue; }
      if (dTo && dt > dTo){ skippedFilter++; continue; }

      const key = `${dateKey}|${league}|${home}|${away}`;
      const res = resIndex.get(key);
      if (!res){ skippedNoRes++; continue; }
      joined++;

      const probs = leagueProb(league, dt, lookback);
      if (!probs){ skippedNoHist++; continue; }

      const qGG = map.gg ? toNumber(r[map.gg]) : NaN;
      const qNG = map.ng ? toNumber(r[map.ng]) : NaN;

      const p = (market === "GG") ? probs.pGG : probs.pNG;
      const q = (market === "GG") ? qGG : qNG;

      if (!Number.isFinite(q) || q <= 1){ skippedNoOdds++; continue; }

      const ev = p*q - 1;
      const take = ev >= minEV;
      if (!take) continue;

      chosen++;

      const isGG = (res.hg > 0 && res.ag > 0);
      const won = (market === "GG") ? isGG : (!isGG);

      const profit = won ? (q - 1) * stake : -stake;

      bets.push({
        date: dateKey,
        league, home, away,
        market,
        p, q, ev,
        won,
        profit,
        lookbackN: probs.n
      });
    }

    // compute KPIs
    let bankroll=0, peak=0, maxDD=0;
    let wins=0, losses=0;
    let sumProfit=0;

    const tb = $("betsTable").querySelector("tbody");
    tb.innerHTML = "";

    // sort bets by date asc for equity curve
    bets.sort((a,b) => (a.date < b.date ? -1 : 1));
    for (const b of bets){
      bankroll += b.profit;
      peak = Math.max(peak, bankroll);
      maxDD = Math.min(maxDD, bankroll - peak); // negative
      sumProfit += b.profit;
      if (b.won) wins++; else losses++;

      const tr = document.createElement("tr");
      const verdict = b.won ? `<span class="pill ok">Vinta</span>` : `<span class="pill bad">Persa</span>`;
      tr.innerHTML = `
        <td>${b.date}</td>
        <td>${b.league}</td>
        <td>${b.home} - ${b.away}</td>
        <td>${b.market}</td>
        <td>${pct(b.p)}</td>
        <td>${fmt(b.q,2)}</td>
        <td>${(b.ev>=0?"+":"") + (b.ev*100).toFixed(1)}%</td>
        <td>${verdict}</td>
        <td>${(b.profit>=0?"+":"") + b.profit.toFixed(2)}</td>
        <td>${bankroll.toFixed(2)}</td>
        <td>${b.lookbackN}</td>
      `;
      tb.appendChild(tr);
    }

    const nBets = bets.length;
    const totalStaked = nBets * stake;
    const roi = totalStaked > 0 ? (sumProfit / totalStaked) : 0;
    const hit = nBets > 0 ? (wins / nBets) : 0;

    const kpis = $("kpis");
    kpis.style.display = "flex";
    kpis.innerHTML = `
      <div class="box"><div class="v">${scanned}</div><div class="t">Righe quote lette</div></div>
      <div class="box"><div class="v">${joined}</div><div class="t">Match uniti a risultati</div></div>
      <div class="box"><div class="v">${nBets}</div><div class="t">Bets (EV ≥ soglia)</div></div>
      <div class="box"><div class="v">${pct(hit)}</div><div class="t">Hit-rate</div></div>
      <div class="box"><div class="v">${sumProfit.toFixed(2)}</div><div class="t">Profitto totale</div></div>
      <div class="box"><div class="v">${pct(roi)}</div><div class="t">ROI su stake</div></div>
      <div class="box"><div class="v">${maxDD.toFixed(2)}</div><div class="t">Max Drawdown</div></div>
    `;

    $("btNote").textContent =
      `Scartati: no risultati=${skippedNoRes}, no storia sufficiente=${skippedNoHist}, quota mancante=${skippedNoOdds}, filtri=${skippedFilter}. ` +
      `Parametri: mercato=${market}, lookback=${lookback}, soglia EV=${(minEV*100).toFixed(1)}%, stake=${stake}.`;

    $("btnExportBets").disabled = bets.length === 0;

    $("oddsStatus").innerHTML = `<span class="pill ok">OK</span> Backtest completato.`;

  } catch(err){
    $("oddsStatus").innerHTML = `<span class="pill bad">ERRORE</span> ${err.message}`;
  }
});

/* ============ export bets ============ */
$("btnExportBets").addEventListener("click", () => {
  const rows = bets.map(b => ({
    date: b.date,
    league: b.league,
    home_team: b.home,
    away_team: b.away,
    market: b.market,
    p_est: (b.p*100).toFixed(2),
    odds: fmt(b.q,2),
    ev_pct: (b.ev*100).toFixed(2),
    won: b.won ? "1" : "0",
    profit: b.profit.toFixed(2),
    lookbackN: b.lookbackN
  }));
  downloadCSV("syncras_backtest_bets.csv",
    ["date","league","home_team","away_team","market","p_est","odds","ev_pct","won","profit","lookbackN"],
    rows
  );
});
</script>
</body>
</html>


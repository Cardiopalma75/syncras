<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Syncras – U/O 2.5 (GA + Bonus X + Spread) • % spiegabili • Backtest</title>
  <style>
    :root{--violet:#6C5CE7;--bg:#f7f7fb;--card:#fff;--border:#e7e7f5;--text:#111827;--muted:#6b7280}
    body{font-family:system-ui,Arial;margin:18px;background:var(--bg);color:var(--text)}
    h2{margin:0 0 10px 0}
    .muted{color:var(--muted)}
    .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:14px;margin-top:14px}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    .grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:10px}
    @media(max-width:980px){.grid{grid-template-columns:1fr}}
    input,select,button{padding:9px;border-radius:12px;border:1px solid #cfcfe6}
    input[type="file"]{padding:10px}
    button{cursor:pointer;background:var(--violet);color:#fff;border:0;font-weight:900;padding:12px 14px;border-radius:14px}
    button:hover{filter:brightness(.96)}
    .btn2{background:#111827}
    hr{border:none;border-top:1px solid #e9e9f7}
    .pill{display:inline-flex;gap:6px;align-items:center;border:1px solid var(--border);background:#fafafe;border-radius:999px;padding:6px 10px;font-size:12px;color:#555}
    table{border-collapse:collapse;width:100%;margin-top:12px;background:#fff;border:1px solid var(--border);border-radius:14px;overflow:hidden}
    th,td{border-bottom:1px solid #eee;padding:8px;text-align:right;font-size:13px;vertical-align:top}
    th{background:#fafafe;color:#333;font-size:12px}
    th:first-child,td:first-child{text-align:left}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .tag{display:inline-flex;align-items:center;border-radius:999px;padding:4px 10px;font-size:12px;font-weight:900}
    .tagOver{background:#ecfdf5;color:#067a50;border:1px solid #a7f3d0}
    .tagUnder{background:#eff6ff;color:#1d4ed8;border:1px solid #bfdbfe}
    .tagMid{background:#fff7ed;color:#b45309;border:1px solid #fed7aa}
    .scoreBox{display:inline-flex;flex-direction:column;gap:2px}
    .big{font-weight:1000;font-size:14px}
    .small{font-size:11px;color:#6b7280;line-height:1.25}
  </style>
</head>
<body>
  <h2>Syncras – Under/Over 2.5 (GA = base • X = bonus • Spread = contesto)</h2>
  <div class="muted">
    ✅ Output: match <b>OVER-friendly</b> / <b>UNDER-friendly</b> con <b>% probabilità (spiegabile)</b> sempre visibile.
    <br>✅ Se il match è già giocato: vedi anche <b>risultato finale</b>. Se futuro: <b>?</b>.
    <br><small>Studio informativo. Nessun invito a scommettere.</small>
  </div>

  <div class="card">
    <div class="grid">
      <div>
        <label><b>CSV RISULTATI (giocato)</b></label><br>
        <input id="csvResultsFile" type="file" accept=".csv,text/csv" style="width:100%">
        <small class="muted">Colonne tipiche: <span class="mono">date, home_team, away_team, FTHG, FTAG</span></small>
      </div>

      <div>
        <label><b>CSV QUOTE (pre-match 1/X/2)</b></label><br>
        <input id="csvQuotesFile" type="file" accept=".csv,text/csv" style="width:100%">
        <small class="muted">Colonne attese: <span class="mono">date, home_team, away_team, b365_1, b365_x, b365_2</span></small>
      </div>

      <div>
        <label><b>2 tasti</b></label><br>
        <div class="row">
          <span class="pill">✅ Attenziona</span>
          <span class="pill">✅ % spiegabile (GA+X+Spread)</span>
          <span class="pill">✅ Backtest prese</span>
        </div>
        <small class="muted" style="display:block;margin-top:10px">
          Nota: la % usa le “foto” (bin) derivate dai tuoi risultati storici.
        </small>
      </div>
    </div>

    <hr style="margin:14px 0">

    <div class="row">
      <label>N recenti (GA)</label><input id="N" type="number" value="12" style="width:90px">
      <label>Top per categoria</label><input id="topK" type="number" value="5" style="width:90px">
      <span class="pill">spread = <span class="mono">|quota1 - quota2|</span></span>
    </div>

    <div class="row" style="margin-top:10px">
      <label>Soglia OVER-friendly</label><input id="thrOver" type="number" value="60" style="width:90px">
      <label>Soglia UNDER-friendly</label><input id="thrUnder" type="number" value="40" style="width:90px">

      <label>Peso GA</label><input id="wGA" type="number" value="0.40" step="0.05" style="width:90px">
      <label>Peso spread</label><input id="wSP" type="number" value="0.35" step="0.05" style="width:90px">
      <label>Peso X</label><input id="wX" type="number" value="0.25" step="0.05" style="width:90px">
    </div>

    <small class="muted" style="display:block;margin-top:8px">
      Default = coerente coi tuoi test: GA pesa di più, spread conta molto, X è bonus/conferma.
    </small>

    <hr style="margin:14px 0">

    <div class="row">
      <button id="attBtn" type="button">ATTENZIONA (Over/Under friendly)</button>
      <button id="btBtn" type="button" class="btn2">BACKTEST (pre-match prese)</button>
      <span id="status" class="muted"></span>
    </div>
  </div>

  <div id="output"></div>

<script>
/* ========= UTIL ========= */
function normTeam(s){ return String(s||"").trim().toLowerCase(); }
function normKey(s){ return String(s||"").trim().toLowerCase(); }
function toNum(x){ const s=String(x??"").trim().replace(",","."); const n=Number(s); return Number.isFinite(n)?n:NaN; }
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function fmtNum(x){ return Number.isFinite(x)?x.toFixed(2):"—"; }
function fmtPct01(x){ return Number.isFinite(x)?(x*100).toFixed(1)+"%":"—"; }

function parseCSV(text){
  const rows=[]; let row=[], cur="", inQ=false;
  for(let i=0;i<text.length;i++){
    const ch=text[i], nx=text[i+1];
    if(ch === '"'){ if(inQ && nx === '"'){ cur+='"'; i++; } else inQ=!inQ; continue; }
    if(!inQ && (ch===',' || ch===';')){ row.push(cur); cur=""; continue; }
    if(!inQ && ch==='\n'){ row.push(cur); rows.push(row); row=[]; cur=""; continue; }
    if(!inQ && ch==='\r') continue;
    cur+=ch;
  }
  row.push(cur); rows.push(row);
  if(rows.length && rows[rows.length-1].every(c=>String(c).trim()==="")) rows.pop();
  const header=(rows[0]||[]).map(x=>String(x).trim());
  return rows.slice(1).map(r=>{
    const o={};
    for(let i=0;i<header.length;i++) o[header[i]] = String(r[i]??"").trim().replace(/"/g,"");
    return o;
  });
}
function pick(o, keys){
  const map={}; for(const k in o) map[normKey(k)] = o[k];
  for(const k of keys){ const v=map[normKey(k)]; if(v!==undefined) return v; }
  return undefined;
}
function parseDateTs(s){
  const t=String(s??"").trim(); if(!t) return NaN;
  if(/^\d{4}-\d{2}-\d{2}$/.test(t)) return Date.parse(t+"T00:00:00Z");
  let m=t.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
  if(m){
    const dd=+m[1], mm=+m[2], yyyy=+m[3];
    const iso=`${String(yyyy).padStart(4,'0')}-${String(mm).padStart(2,'0')}-${String(dd).padStart(2,'0')}`;
    return Date.parse(iso+"T00:00:00Z");
  }
  m=t.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2})$/);
  if(m){
    const dd=+m[1], mm=+m[2], yy=+m[3];
    const yyyy=(yy>=70)?(1900+yy):(2000+yy);
    const iso=`${yyyy}-${String(mm).padStart(2,'0')}-${String(dd).padStart(2,'0')}`;
    return Date.parse(iso+"T00:00:00Z");
  }
  const x=Date.parse(t); return Number.isFinite(x)?x:NaN;
}
function normResultRow(o){
  const dateStr=String(pick(o,["date","match_date","data","giorno","Date","DATA"])||"").trim();
  const home_team=normTeam(pick(o,["home_team","hometeam","home","HomeTeam","CASA"])||"");
  const away_team=normTeam(pick(o,["away_team","awayteam","away","AwayTeam","TRASFERTA"])||"");
  const FTHG=pick(o,["FTHG","fthg","hg","home_goals","HomeGoals"]) ?? "";
  const FTAG=pick(o,["FTAG","ftag","ag","away_goals","AwayGoals"]) ?? "";
  const dateTs=parseDateTs(dateStr);
  return {dateStr,dateTs,home_team,away_team,FTHG:String(FTHG).trim(),FTAG:String(FTAG).trim()};
}
function normQuoteRow(o){
  const dateStr=String(pick(o,["date","match_date","data","giorno","Date","DATA"])||"").trim();
  const home_team=normTeam(pick(o,["home_team","hometeam","home","HomeTeam","CASA"])||"");
  const away_team=normTeam(pick(o,["away_team","awayteam","away","AwayTeam","TRASFERTA"])||"");
  const b365_1=pick(o,["b365_1","b365_h","B365H","odd1","odds_1","1","home"]) ?? "";
  const b365_x=pick(o,["b365_x","B365D","oddx","odds_x","X","draw"]) ?? "";
  const b365_2=pick(o,["b365_2","b365_a","B365A","odd2","odds_2","2","away"]) ?? "";
  const dateTs=parseDateTs(dateStr);
  return {dateStr,dateTs,home_team,away_team,b365_1:String(b365_1).trim(),b365_x:String(b365_x).trim(),b365_2:String(b365_2).trim()};
}
function keyOf(dateTs,home,away){ return `${dateTs}|${home}|${away}`; }
async function readFileText(file){
  return new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(String(r.result||"")); r.onerror=rej; r.readAsText(file); });
}

/* ========= GA (mu) ========= */
function lastNMatches(results, team, N, beforeTs){
  return results
    .filter(r=>Number.isFinite(r.dateTs) && r.dateTs < beforeTs && (r.home_team===team || r.away_team===team))
    .sort((a,b)=>b.dateTs - a.dateTs)
    .slice(0,N);
}
function teamGFGA(results, team, N, beforeTs){
  const ms=lastNMatches(results,team,N,beforeTs);
  let gf=0, ga=0, n=0;
  for(const m of ms){
    const hg=toNum(m.FTHG), ag=toNum(m.FTAG);
    if(!Number.isFinite(hg) || !Number.isFinite(ag)) continue;
    if(m.home_team===team){ gf+=hg; ga+=ag; } else { gf+=ag; ga+=hg; }
    n++;
  }
  if(n<3) return {gf:NaN,ga:NaN,n};
  return {gf:gf/n, ga:ga/n, n};
}
function estimateMu(results, home, away, N, dateTs){
  const h=teamGFGA(results,home,N,dateTs);
  const a=teamGFGA(results,away,N,dateTs);
  if(!Number.isFinite(h.gf) || !Number.isFinite(h.ga) || !Number.isFinite(a.gf) || !Number.isFinite(a.ga)) return NaN;
  const muHome=(h.gf + a.ga)/2;
  const muAway=(a.gf + h.ga)/2;
  let mu = muHome + muAway;
  return clamp(mu, 1.4, 4.2);
}

/* ========= SCORE UNICO (0..100) ========= */
function xScore(oddX){
  if(!Number.isFinite(oddX)) return NaN;
  return clamp((oddX - 3.20) / (5.50 - 3.20), 0, 1);
}
function spScore(spread){
  if(!Number.isFinite(spread)) return NaN;
  const peak=2.0, left=0.0, right=6.5;
  if(spread<=peak) return clamp((spread-left)/(peak-left), 0, 1);
  return clamp((right-spread)/(right-peak), 0, 1);
}
function gaScore(mu){
  if(!Number.isFinite(mu)) return NaN;
  return clamp((mu - 2.40) / (3.80 - 2.40), 0, 1);
}
function computeScore(oddX, spread, mu, wGA, wSP, wX){
  const xs=xScore(oddX), ss=spScore(spread), gs=gaScore(mu);
  if(!Number.isFinite(xs) || !Number.isFinite(ss) || !Number.isFinite(gs)) return {score:NaN, xs, ss, gs};
  const sum = (wGA+wSP+wX) || 1;
  const s = (wGA*gs + wSP*ss + wX*xs) / sum;
  return {score: s*100, xs, ss, gs};
}
function tagFromScore(s, thrOver, thrUnder){
  if(!Number.isFinite(s)) return {txt:"NA", cls:"tagMid"};
  if(s>=thrOver) return {txt:"OVER-friendly", cls:"tagOver"};
  if(s<=thrUnder) return {txt:"UNDER-friendly", cls:"tagUnder"};
  return {txt:"NEUTRA", cls:"tagMid"};
}

/* ========= % PROBABILITÀ (spiegabile) =========
   - Base over-rate: 57% (dal tuo dataset)
   - Poi aggiungo/sottraggo delte dai bin:
     pOverPred = base + wGA*(pOver_GA - base) + wX*(pOver_X - base) + wSP*(pOver_SP - base)
*/
const BASE_OVER = 0.57;

// Bins (derivati dai numeri che hai incollato)
const BINS_GA = [
  {min:2.60, max:3.00, pOver:0.619, label:"GA 2.60–3.00"},
  {min:3.00, max:3.40, pOver:0.640, label:"GA 3.00–3.40"},
  {min:3.40, max:3.80, pOver:0.630, label:"GA 3.40–3.80"},
  {min:3.80, max:Infinity, pOver:0.797, label:"GA 3.80+"},
];

const BINS_X = [
  {min:2.00, max:3.00, pOver:0.364, label:"X 2.00–3.00"},
  {min:3.00, max:4.00, pOver:0.502, label:"X 3.00–4.00"},
  {min:4.00, max:5.00, pOver:0.664, label:"X 4.00–5.00"},
  {min:5.00, max:6.00, pOver:0.646, label:"X 5.00–6.00"},
  {min:6.00, max:7.00, pOver:0.639, label:"X 6.00–7.00"},
  {min:7.00, max:8.00, pOver:0.742, label:"X 7.00–8.00"},
  {min:8.00, max:Infinity, pOver:0.684, label:"X 8.00+"},
];

const BINS_SPREAD = [
  {min:-Infinity, max:0.50, pOver:0.589, label:"Spread <0.50"},
  {min:0.50, max:1.00, pOver:0.659, label:"Spread 0.50–1.00"},
  {min:1.00, max:2.00, pOver:0.738, label:"Spread 1.00–2.00"},
  {min:2.00, max:3.00, pOver:0.709, label:"Spread 2.00–3.00"},
  {min:3.00, max:4.00, pOver:0.607, label:"Spread 3.00–4.00"},
  {min:4.00, max:5.00, pOver:0.654, label:"Spread 4.00–5.00"},
  {min:5.00, max:6.50, pOver:0.622, label:"Spread 5.00–6.50"},
  {min:6.50, max:Infinity, pOver:0.663, label:"Spread 6.50+"},
];

function binLookup(value, bins){
  if(!Number.isFinite(value)) return {pOver:BASE_OVER, label:"(bin NA)"};
  for(const b of bins){
    if(value>=b.min && value<b.max) return {pOver:b.pOver, label:b.label};
  }
  return {pOver:BASE_OVER, label:"(bin default)"};
}

function predictOverProb(mu, oddX, spread, wGA, wSP, wX){
  const ga = binLookup(mu, BINS_GA);
  const xb = binLookup(oddX, BINS_X);
  const sp = binLookup(spread, BINS_SPREAD);

  const base = BASE_OVER;
  const p = base
    + wGA*(ga.pOver - base)
    + wX*(xb.pOver - base)
    + wSP*(sp.pOver - base);

  const pClamped = clamp(p, 0.05, 0.95);

  return {
    pOver: pClamped,
    parts: {
      base,
      ga, xb, sp,
      deltaGA: ga.pOver - base,
      deltaX: xb.pOver - base,
      deltaSP: sp.pOver - base
    }
  };
}

/* ========= RENDER ========= */
function renderPickTable(title, arr){
  const rows = arr.map(x=>{
    const t=tagFromScore(x.score, x.thrOver, x.thrUnder);

    const pPick = (x.pick==="OVER") ? x.pOver : (1-x.pOver);
    const pTxt = fmtPct01(pPick);

    const resTxt = x.played ? `${x.FTHG}-${x.FTAG}` : "?";
    const outcomeTxt = x.played ? (x.isHit ? "HIT" : "MISS") : "—";

    return `
      <tr>
        <td>
          <b>${x.home} — ${x.away}</b><br>
          <small class="muted">${x.dateStr}</small>
        </td>

        <td class="mono">
          ${fmtNum(x.odd1)} / <b>${fmtNum(x.oddX)}</b> / ${fmtNum(x.odd2)}<br>
          <small class="muted">spread=${fmtNum(x.spread)}</small>
        </td>

        <td class="mono">
          mu=${fmtNum(x.mu)}<br>
          <small class="muted">${x.gaLabel}</small>
        </td>

        <td class="mono">
          <div class="scoreBox">
            <span class="big">${x.score.toFixed(1)}</span>
            <span class="small">GA=${(x.gs*100).toFixed(0)} • SP=${(x.ss*100).toFixed(0)} • X=${(x.xs*100).toFixed(0)}</span>
          </div>
        </td>

        <td>
          <span class="tag ${t.cls}">${t.txt}</span><br>
          <small class="muted">Pick: <b>${x.pick}</b></small><br>
          <small class="muted">P(successo): <b>${pTxt}</b></small><br>
          <small class="muted">${x.xLabel} • ${x.spLabel}</small>
        </td>

        <td class="mono">
          <b>${resTxt}</b><br>
          <small class="muted">${outcomeTxt}</small>
        </td>
      </tr>
    `;
  }).join("") || `<tr><td colspan="6" class="muted">Nessun match trovato</td></tr>`;

  return `
    <div class="card">
      <b>${title}</b>
      <table>
        <thead>
          <tr>
            <th>Match</th>
            <th>Quote 1 / X / 2</th>
            <th>GA (mu)</th>
            <th>Score unico</th>
            <th>Etichetta + %</th>
            <th>Risultato</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
      <small class="muted">
        P(successo) = probabilità empirica spiegabile: base 57% + aggiustamenti dai bin di GA, X, Spread (pesati con i tuoi pesi).
      </small>
    </div>
  `;
}

/* ========= 1) ATTENZIONA ========= */
async function attenziona(){
  const status=document.getElementById("status");
  const output=document.getElementById("output");
  status.textContent="Carico CSV…";
  output.innerHTML="";

  try{
    const fRes=document.getElementById("csvResultsFile").files?.[0];
    const fQuo=document.getElementById("csvQuotesFile").files?.[0];
    if(!fRes || !fQuo){ status.textContent="⚠️ Seleziona entrambi i CSV."; return; }

    const N=+document.getElementById("N").value||12;
    const topK=Math.max(1,+document.getElementById("topK").value||5);
    const thrOver=+document.getElementById("thrOver").value||60;
    const thrUnder=+document.getElementById("thrUnder").value||40;

    let wGA=+document.getElementById("wGA").value||0.40;
    let wSP=+document.getElementById("wSP").value||0.35;
    let wX=+document.getElementById("wX").value||0.25;

    const resText=await readFileText(fRes);
    const quoText=await readFileText(fQuo);

    const results=parseCSV(resText).map(normResultRow).filter(r=>r.dateStr && r.home_team && r.away_team && Number.isFinite(r.dateTs));
    const quotes=parseCSV(quoText).map(normQuoteRow).filter(q=>q.dateStr && q.home_team && q.away_team && Number.isFinite(q.dateTs));

    const resMap=new Map();
    for(const r of results) resMap.set(keyOf(r.dateTs,r.home_team,r.away_team), r);

    status.textContent="Calcolo score + %…";

    const all=[];
    let matched=0, future=0;

    for(const q of quotes){
      const odd1=toNum(q.b365_1), odd2=toNum(q.b365_2), oddX=toNum(q.b365_x);
      const spread=(Number.isFinite(odd1)&&Number.isFinite(odd2))?Math.abs(odd1-odd2):NaN;

      const mu=estimateMu(results, q.home_team, q.away_team, N, q.dateTs);
      if(!Number.isFinite(mu)) continue;

      const comp=computeScore(oddX, spread, mu, wGA, wSP, wX);
      if(!Number.isFinite(comp.score)) continue;

      const pr = predictOverProb(mu, oddX, spread, wGA, wSP, wX);

      const r=resMap.get(keyOf(q.dateTs,q.home_team,q.away_team));
      const played = !!r;
      if(played) matched++; else future++;

      let FTHG="?", FTAG="?", isOver=null, isHit=null;

      // pick: uso score (>=50 OVER, <50 UNDER) solo per la "verifica" se giocato
      const pick = (comp.score>=50) ? "OVER" : "UNDER";
      if(played){
        FTHG=r.FTHG; FTAG=r.FTAG;
        const hg=toNum(r.FTHG), ag=toNum(r.FTAG);
        if(Number.isFinite(hg)&&Number.isFinite(ag)){
          isOver = (hg+ag)>=3;
          if(pick==="OVER") isHit = isOver;
          if(pick==="UNDER") isHit = !isOver;
        }
      }

      all.push({
        dateStr:q.dateStr, home:q.home_team, away:q.away_team,
        odd1, oddX, odd2, spread, mu,
        score: comp.score, xs:comp.xs, ss:comp.ss, gs:comp.gs,
        thrOver, thrUnder,
        pOver: pr.pOver,
        gaLabel: pr.parts.ga.label,
        xLabel: pr.parts.xb.label,
        spLabel: pr.parts.sp.label,
        pick,
        played, FTHG, FTAG, isHit
      });
    }

    // Ordino per score: top over e top under
    const overList = all.slice().sort((a,b)=>b.score-a.score).slice(0, topK);
    const underList = all.slice().sort((a,b)=>a.score-b.score).slice(0, topK);

    output.innerHTML = `
      <div class="card">
        <b>Impostazioni</b>
        <div class="row" style="margin-top:10px">
          <span class="pill"><b>N recenti:</b> ${N}</span>
          <span class="pill"><b>Pesi:</b> GA=${wGA.toFixed(2)} • spread=${wSP.toFixed(2)} • X=${wX.toFixed(2)}</span>
          <span class="pill"><b>Soglie:</b> OVER≥${thrOver} • UNDER≤${thrUnder}</span>
          <span class="pill"><b>Quote valutate:</b> ${all.length}</span>
          <span class="pill"><b>Giocati:</b> ${matched} • <b>Futuri:</b> ${future}</span>
        </div>

        <small class="muted" style="display:block;margin-top:10px">
          La colonna <b>P(successo)</b> è sempre presente:
          se pick=OVER mostra P(Over); se pick=UNDER mostra P(Under)=1−P(Over).
        </small>
      </div>

      ${renderPickTable("TOP OVER-friendly (score più alto)", overList)}
      ${renderPickTable("TOP UNDER-friendly (score più basso)", underList)}
    `;

    status.textContent="Completato ✅";
  }catch(e){
    status.textContent="Errore: " + (e?.message || e);
  }
}

/* ========= 2) BACKTEST =========
   - su match matchati (quote+risultati)
   - pick=OVER se score>=50 else UNDER
   - mostro anche perché: HR per OVER-friendly/NEUTRA/UNDER-friendly
*/
async function backtest(){
  const status=document.getElementById("status");
  const output=document.getElementById("output");
  status.textContent="BACKTEST: carico CSV…";
  output.innerHTML="";

  try{
    const fRes=document.getElementById("csvResultsFile").files?.[0];
    const fQuo=document.getElementById("csvQuotesFile").files?.[0];
    if(!fRes || !fQuo){ status.textContent="⚠️ Seleziona entrambi i CSV."; return; }

    const N=+document.getElementById("N").value||12;
    const thrOver=+document.getElementById("thrOver").value||60;
    const thrUnder=+document.getElementById("thrUnder").value||40;

    let wGA=+document.getElementById("wGA").value||0.40;
    let wSP=+document.getElementById("wSP").value||0.35;
    let wX=+document.getElementById("wX").value||0.25;

    const resText=await readFileText(fRes);
    const quoText=await readFileText(fQuo);

    const results=parseCSV(resText).map(normResultRow).filter(r=>r.dateStr && r.home_team && r.away_team && Number.isFinite(r.dateTs));
    const quotes=parseCSV(quoText).map(normQuoteRow).filter(q=>q.dateStr && q.home_team && q.away_team && Number.isFinite(q.dateTs));

    const resMap=new Map();
    for(const r of results) resMap.set(keyOf(r.dateTs,r.home_team,r.away_team), r);

    let matched=0, notMatched=0;
    let taken=0, hit=0, miss=0;

    let takeOver=0, hitOver=0, sumOddOver=0, nOddOver=0;
    let takeUnder=0, hitUnder=0, sumOddUnder=0, nOddUnder=0;

    const byTag = { over:{n:0, hit:0}, mid:{n:0, hit:0}, under:{n:0, hit:0} };

    status.textContent="BACKTEST: calcolo…";

    for(const q of quotes){
      const r=resMap.get(keyOf(q.dateTs,q.home_team,q.away_team));
      if(!r){ notMatched++; continue; }

      const hg=toNum(r.FTHG), ag=toNum(r.FTAG);
      if(!Number.isFinite(hg) || !Number.isFinite(ag)) continue;
      const isOver = (hg+ag)>=3;

      const odd1=toNum(q.b365_1), odd2=toNum(q.b365_2), oddX=toNum(q.b365_x);
      const spread=(Number.isFinite(odd1)&&Number.isFinite(odd2))?Math.abs(odd1-odd2):NaN;

      const mu=estimateMu(results, q.home_team, q.away_team, N, q.dateTs);
      if(!Number.isFinite(mu)) continue;

      const comp=computeScore(oddX, spread, mu, wGA, wSP, wX);
      if(!Number.isFinite(comp.score)) continue;

      matched++;
      taken++;

      const tag = tagFromScore(comp.score, thrOver, thrUnder);
      const pick = (comp.score>=50) ? "OVER" : "UNDER";

      let win=false;
      if(pick==="OVER"){
        takeOver++;
        if(Number.isFinite(oddX)){ /* niente */ }
        // quota media (se esistono quote O/U nel csv non ci sono qui), quindi uso b365_x come proxy? NO.
        // meglio: qui non abbiamo quota Over 2.5, quindi lasciamo solo conteggi.
        win = isOver;
        if(win) hitOver++;
      }else{
        takeUnder++;
        win = !isOver;
        if(win) hitUnder++;
      }

      if(win){ hit++; } else { miss++; }

      if(tag.txt==="OVER-friendly"){ byTag.over.n++; if(win) byTag.over.hit++; }
      else if(tag.txt==="UNDER-friendly"){ byTag.under.n++; if(win) byTag.under.hit++; }
      else { byTag.mid.n++; if(win) byTag.mid.hit++; }
    }

    const hr = taken ? (hit/taken) : NaN;
    const hrOver = takeOver ? (hitOver/takeOver) : NaN;
    const hrUnder = takeUnder ? (hitUnder/takeUnder) : NaN;

    const hrTag = (obj)=> obj.n ? (100*obj.hit/obj.n).toFixed(1)+"%" : "—";

    output.innerHTML = `
      <div class="card">
        <b>BACKTEST – “quante prese pre-match” + perché funzionano</b>

        <div class="row" style="margin-top:10px">
          <span class="pill"><b>Match matchati:</b> ${matched}</span>
          <span class="pill"><b>Non matchati:</b> ${notMatched}</span>
          <span class="pill"><b>PRESE:</b> ${taken}</span>
          <span class="pill"><b>Hit:</b> ${hit}</span>
          <span class="pill"><b>Miss:</b> ${miss}</span>
          <span class="pill"><b>Hit-rate:</b> ${Number.isFinite(hr)?(hr*100).toFixed(1)+"%":"—"}</span>
        </div>

        <hr style="margin:12px 0">

        <div class="row">
          <span class="pill"><b>Pick OVER:</b> ${takeOver} (hit ${hitOver}, HR ${Number.isFinite(hrOver)?(hrOver*100).toFixed(1)+"%":"—"})</span>
          <span class="pill"><b>Pick UNDER:</b> ${takeUnder} (hit ${hitUnder}, HR ${Number.isFinite(hrUnder)?(hrUnder*100).toFixed(1)+"%":"—"})</span>
        </div>

        <hr style="margin:12px 0">

        <div class="row">
          <span class="pill"><b>OVER-friendly:</b> ${byTag.over.n} (HR ${hrTag(byTag.over)})</span>
          <span class="pill"><b>NEUTRA:</b> ${byTag.mid.n} (HR ${hrTag(byTag.mid)})</span>
          <span class="pill"><b>UNDER-friendly:</b> ${byTag.under.n} (HR ${hrTag(byTag.under)})</span>
        </div>

        <small class="muted" style="display:block;margin-top:10px">
          Lettura corretta (quella che volevi tu): se <b>OVER-friendly</b> ha HR più alta della NEUTRA, lo score sta catturando un pattern reale.
          E la % che mostriamo nei match è la versione “spiegabile” di quel pattern (GA + bonus X + spread).
        </small>

        <small style="display:block;margin-top:10px">
          Set: N=${N}, pesi GA=${wGA.toFixed(2)}, spread=${wSP.toFixed(2)}, X=${wX.toFixed(2)} • soglie OVER≥${thrOver}, UNDER≤${thrUnder}. Base Over=${(BASE_OVER*100).toFixed(1)}%.
        </small>
      </div>
    `;

    status.textContent="BACKTEST completato ✅";
  }catch(e){
    status.textContent="Errore BACKTEST: " + (e?.message || e);
  }
}

document.getElementById("attBtn").addEventListener("click", attenziona);
document.getElementById("btBtn").addEventListener("click", backtest);
</script>
</body>
</html>
